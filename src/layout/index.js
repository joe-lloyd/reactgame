import Brick from '../brick';
/**
 * @class Layout
 *
 * @description
 * Builds the brick layout for the level
 *
 */
export default class Layout {

	constructor (canvas, ctx) {
		this.canvas = canvas;
		this.ctx = ctx;
		this.bricks = [];
		this.init();
	}

	/**
	 * @description
	 * initialize the layout
	 *
	 */
	init () {
		let layout = this.getLayout();
		let y;
		let x;
		let row;
		let pos;
		let standardWidth = this.canvas.width / 20;
		let standardHeight = this.canvas.height / 20;

		for (let [index, value] of layout.entries()) {
			row = Math.floor(index / 20);
			pos = index % 20;
			if (value === 1) {
				x = pos * standardWidth;
				y = row * standardHeight;

				let brick = new Brick(this.canvas, this.ctx, x, y);
				this.bricks.push(brick);
			}
		}
	}

	/**
	 * @description
	 * Using an array of numbers we can set different layouts
	 *
	 * @returns {Array}
	 */
	getLayout () {
		switch (this.getRandomArbitrary(0, 10)) {
			case 0 : {
				return [
					0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,0,0,0,
					0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,0,0,
					0,0,1,1,1,0,1,0,1,0,1,0,0,0,1,1,0,0,0,0,
					0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,0,0,
					0,0,1,0,0,0,1,1,1,0,1,1,1,0,1,0,1,0,0,0
				];
			}
			case 1 : {
				return [
					0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,0,0,0,
					0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,0,0,
					0,0,1,1,1,0,1,0,1,0,1,0,0,0,1,1,0,0,0,0,
					0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,0,0,
					0,0,1,0,0,0,1,1,1,0,1,1,1,0,1,0,1,0,0,0
				];
			}
			case 2 : {
				return [
					0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,0,0,0,
					0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,0,0,
					0,0,1,1,1,0,1,0,1,0,1,0,0,0,1,1,0,0,0,0,
					0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,0,0,
					0,0,1,0,0,0,1,1,1,0,1,1,1,0,1,0,1,0,0,0
				];
			}
			case 3 : {
				return [
					0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,0,0,0,
					0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,0,0,
					0,0,1,1,1,0,1,0,1,0,1,0,0,0,1,1,0,0,0,0,
					0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,0,0,
					0,0,1,0,0,0,1,1,1,0,1,1,1,0,1,0,1,0,0,0
				];
			}
			case 4 : {
				return [
					0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,0,0,0,
					0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,0,0,
					0,0,1,1,1,0,1,0,1,0,1,0,0,0,1,1,0,0,0,0,
					0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,0,0,
					0,0,1,0,0,0,1,1,1,0,1,1,1,0,1,0,1,0,0,0
				];
			}
			case 5 : {
				return [
					0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,0,0,0,
					0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,0,0,
					0,0,1,1,1,0,1,0,1,0,1,0,0,0,1,1,0,0,0,0,
					0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,0,0,
					0,0,1,0,0,0,1,1,1,0,1,1,1,0,1,0,1,0,0,0
				];
			}
			case 6 : {
				return [
					0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,0,0,0,
					0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,0,0,
					0,0,1,1,1,0,1,0,1,0,1,0,0,0,1,1,0,0,0,0,
					0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,0,0,
					0,0,1,0,0,0,1,1,1,0,1,1,1,0,1,0,1,0,0,0
				];
			}
			case 7 : {
				return [
					0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,0,0,0,
					0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,0,0,
					0,0,1,1,1,0,1,0,1,0,1,0,0,0,1,1,0,0,0,0,
					0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,0,0,
					0,0,1,0,0,0,1,1,1,0,1,1,1,0,1,0,1,0,0,0
				];
			}
			case 8 : {
				return [
					0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,0,0,0,
					0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,0,0,
					0,0,1,1,1,0,1,0,1,0,1,0,0,0,1,1,0,0,0,0,
					0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,0,0,
					0,0,1,0,0,0,1,1,1,0,1,1,1,0,1,0,1,0,0,0
				];
			}
			case 9 : {
				return [
					0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,0,0,0,
					0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,0,0,
					0,0,1,1,1,0,1,0,1,0,1,0,0,0,1,1,0,0,0,0,
					0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,0,0,
					0,0,1,0,0,0,1,1,1,0,1,1,1,0,1,0,1,0,0,0
				];
			}
		}
	}

	getRandomArbitrary (min, max) {
		min = Math.ceil(min);
		max = Math.floor(max);
		return Math.floor(Math.random() * (max - min)) + min;
	}

	/**
	 * @description
	 * draw each block
	 */
	draw () {
		for (let [index, value] of this.bricks.entries()) {
			if (value) {
				value.draw();
			}
		}
	}
}